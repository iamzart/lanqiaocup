位运算操作符
这些操作符只能用于整数，char也可以，也是整形家族

/*左移操作符*/
int num = 10;
num << i;
将num的二进制表示，左移i位，移动的是补码
一个整型，占四个字节，32个比特位
实际的num变了，移位的结果变了，num相当于一个操作数
左移一位，有*2的效果
左移：左边丢一个，右边补0


/*右移*/
逻辑右移，算术右移（most）
逻辑：左边填0，佑彬丢弃
算数：左边符号填充，右边丢弃
-1的补码全是1
对于正数有/2的效果

左乘右除

不能移动负数位

/*按位与*/
指的二进制位补码
a&b 
对两个数对应的二进制位的与运算，二者都为1，结果才为1，有0则0


/*按位或*/
a | b
二进制位补码
只要有1就是1，同时为0才是0

/*按位异或*/
a ^ b
相同为0，相异为1

/*按位取反操作符*/
~a,单目操作符，
如果取完是正数，就不用动


/*位运算的应用*/
//判断奇数偶数
偶数的最低二进制位都是0
奇数的最低二进制位都是1

if(x & 1 == 0) --偶数
if(x & 1 == 0) --奇数
/*位运算的应用*/
//判断奇数偶数

/*奇偶数判断*/
//要注意正负数

/*按位与的应用*/
//让一个m的二进制，想保留哪几位就让m那等于1，这样那个数字和m按位与，就会得到那个效果
***用按位与把某位留下来

/*获取二进制的指定位*/
让一个m的二进制，想保留哪几位就让m那等于1，这样那个数字和m按位与，就会得到那个效果

**获得第i位是1or0
只需将那个数右移i位（来到最后一位）
再&1

***获取一个二进制位，右移，用按位与，
或等是给他存起来

/*将指定二进制位设置为一*/
用一个m，指定那为1，就给m哪设置成1，其余都是零，再按位或
x =| m<<i 
或等1往前挪i位

/*将指定位设置为0*/
要设置哪位，就把一个数字的那位设置为0，其余是1，然后这个数字和原数字按位与
x &= ~(1<<i)

/*反转指定二进制位*/
将m的二进制第i位设置为0，其余为1，按位异或
第i就是要反转的那位

/*将二进制中最右边的1变成0*/
x&(x-1)
通常应用于求一个数的二进制序列中有几个1，
md你纠结啥呢！啊！，最右边的1，不是最右边的数字！！
应用场景：统计二进制中1的个数
位图算法：用二进制为便是内存块，1变0，释放

/*只保留二进制位最右边的1*/
x&-x
应用：快速查找最右边的1

/*异或的巧用*/^
相同为0，相异为1
x ^ x = 0  两个相同的数字异或结果是0
0 ^ x = x  0与一个数异或结果还是那个数
异或支持交换率
a ^ b ^a == a ^ a ^ b == 0 ^ b == b
太机智了！
小伙伴
/*交换两个整数的值*/
方法1，创建tmp
方法二，引用&，创建函数
方法三，   a = a^b
		b = a^b      只适用于整形
		a = a^b

/*找出只出现过一次的数字*/
方法一：暴力统计
方法二：异或
啊啊啊啊啊啊啊啊啊！
把数组中所有的数字异或在一起，最后等于几，就是几呀！
因为两两异或等于0

/*268丢失的数字*/
提供一个标准数字数组，然后和输入的数组异或，和找出单身狗有点像了
------------------------------------------------------------------------

操作符属性
**优先级
操作符相邻的时候才要区分
先算优先级高的

**结合性
相邻的操作符优先级一样，哪个先算
结合性说了算




























































































